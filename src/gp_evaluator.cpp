// Generated GP Evaluator - DO NOT EDIT MANUALLY
// Generated from GP with fitness: 0
// GP Length: 82, Depth: 16

#include <cmath>
#include <algorithm>
#include <vector>
#ifndef GP_BUILD
#include <ArduinoEigenDense.h>
#else
#include <Eigen/Dense>
#include <Eigen/Geometry>
#endif
#include "GP/autoc/aircraft_state.h"

static int getIndex(const std::vector<Path>& path, double arg) {
  extern AircraftState aircraftState;
  if (std::isnan(arg)) {
    return aircraftState.getThisPathIndex();
  }
  int steps = CLAMP_DEF((int)arg, -5, 5);
  double distanceSoFar = path.at(aircraftState.getThisPathIndex()).distanceFromStart;
  double distanceGoal = distanceSoFar + steps * 22.0 * (200.0 / 1000.0);
  int currentStep = aircraftState.getThisPathIndex();
  if (steps > 0) {
    while (path.at(currentStep).distanceFromStart < distanceGoal && currentStep < path.size() - 1) {
      currentStep++;
    }
  } else {
    while (path.at(currentStep).distanceFromStart > distanceGoal && currentStep > 0) {
      currentStep--;
    }
  }
  return currentStep;
}

double evaluateGP(AircraftState& aircraftState, const std::vector<Path>& path, double arg) {
  double returnValue;

  returnValue = sin(aircraftState.setRollCommand(([&]() { int temp19 = getIndex(path, ([&]() { int temp18 = getIndex(path, (-aircraftState.setThrottleCommand(cos(sin(([&]() { int temp0 = getIndex(path, 2.0); double distance = (path.at(temp0).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })()))) - (((((([&]() { int temp2 = getIndex(path, sin(([&]() { int temp1 = getIndex(path, 2.0); double distance = (path.at(temp1).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })())); double distance = (path.at(temp2).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })() + ((([&]() { int temp3 = getIndex(path, aircraftState.getPitchCommand()); Eigen::Vector3d craftToTarget = path.at(temp3).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); return std::atan2(projectedVector.y(), -projectedVector.z()); })() + (aircraftState.getPitchCommand() + aircraftState.getRollCommand())) + ([&]() { int temp4 = getIndex(path, ((aircraftState.getRollCommand()) ? (2.0) : (0.0))); Eigen::Vector3d craftToTarget = path.at(temp4).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })()))) > (([&]() { double temp9 = cos(aircraftState.setPitchCommand(([&]() { int temp8 = getIndex(path, ([&]() { int temp7 = getIndex(path, aircraftState.getRollCommand()); double distance = (path.at(temp7).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })()); Eigen::Vector3d craftToTarget = path.at(temp8).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })())); return (temp9 == 0.0) ? 0.0 : (([&]() { int temp6 = getIndex(path, sin(([&]() { int temp5 = getIndex(path, ((0.0) ? (2.0) : (0.0))); Eigen::Vector3d craftToTarget = path.at(temp5).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })())); Eigen::Vector3d craftToTarget = path.at(temp6).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); return std::atan2(projectedVector.y(), -projectedVector.z()); })() / temp9); })()) ? 1.0 : 0.0)) > (([&]() { int temp17 = getIndex(path, (cos(aircraftState.setRollCommand(aircraftState.getThrottleCommand())) * ((([&]() { int temp10 = getIndex(path, ((aircraftState.getRollCommand()) ? (2.0) : (0.0))); Eigen::Vector3d craftToTarget = path.at(temp10).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })()) ? (aircraftState.setThrottleCommand((aircraftState.setThrottleCommand(cos(([&]() { int temp11 = getIndex(path, cos((Eigen::Vector3d(0, 0, -10.0) - aircraftState.getPosition()).norm())); Eigen::Vector3d craftToTarget = path.at(temp11).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })())) + sin(([&]() { double temp16 = ([&]() { int temp15 = getIndex(path, ([&]() { int temp14 = getIndex(path, 1.0); double distance = (path.at(temp14).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })()); Eigen::Vector3d craftToTarget = path.at(temp15).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })(); return (temp16 == 0.0) ? 0.0 : (([&]() { double temp13 = ((M_PI) > (aircraftState.getRollCommand()) ? 1.0 : 0.0); return (temp13 == 0.0) ? 0.0 : (([&]() { int temp12 = getIndex(path, aircraftState.getRollCommand()); double distance = (path.at(temp12).start - aircraftState.getPosition()).norm(); return CLAMP_DEF((distance - 10.0) / aircraftState.getRelVel(), -1.0, 1.0); })() / temp13); })() / temp16); })())))) : ((((0.0) ? (2.0) : (0.0)) * ((((aircraftState.getRelVel()) == (aircraftState.getThrottleCommand()) ? 1.0 : 0.0)) == (sin(aircraftState.getPitchCommand())) ? 1.0 : 0.0)))))); Eigen::Vector3d craftToTarget = path.at(temp17).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })()) ? 1.0 : 0.0))); Eigen::Vector3d craftToTarget = path.at(temp18).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); double rollEstimate = std::atan2(projectedVector.y(), -projectedVector.z()); Eigen::Quaterniond rollRotation(Eigen::AngleAxisd(rollEstimate, Eigen::Vector3d::UnitX())); Eigen::Quaterniond virtualOrientation = aircraftState.getOrientation() * rollRotation; Eigen::Vector3d newLocalTargetVector = virtualOrientation.inverse() * craftToTarget; return std::atan2(-newLocalTargetVector.z(), newLocalTargetVector.x()); })()); Eigen::Vector3d craftToTarget = path.at(temp19).start - aircraftState.getPosition(); Eigen::Vector3d target_local = aircraftState.getOrientation().inverse() * craftToTarget; Eigen::Vector3d projectedVector(0, target_local.y(), target_local.z()); return std::atan2(projectedVector.y(), -projectedVector.z()); })()));

  const double RANGELIMIT = 1000000.0;
  if (returnValue < -RANGELIMIT) return -RANGELIMIT;
  if (returnValue > RANGELIMIT) return RANGELIMIT;
  if (std::abs(returnValue) < 0.000001) return 0.0;
  return returnValue;
}
